tacotron 2
	where is duration generation?
	is that a generative model?

DAR
	where is duration generation?
	is that a generative model?
	what's the distribution?
	what's the sampling procedure?	


Mean-based generation method vs random sampling based generation method

How is duration handled in Tacotron 2?
	Autoregressive attention between decoder and encoder is responsible for handling the duration.


How is duration handled in DAR?


What is the distribution predicted by DAR? How does sampling occur?
	categorical distribution is predicted by DAR
	random sampling is used on the generated outputs


how is pitch generated by neural nets?
what is periodicity?
band periodicity?

no subjective evaluation in vocosnclass Solution:
    def searchNode(self, root: Optional[TreeNode], par: Optional[TreeNode], dir: int, key: int) -> Optional[TreeNode]:
        if not root:
            self.par = None
            return None
        # store parent and direction
        self.keyNodePar = par
        self.dir = dir
        if root.val == key:
            return root

        elif root.val < key:
            return self.searchNode(root.right, root, 0, key)

        else:
            return self.searchNode(root.left, root, 1, key)
    def findPrince(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        curr = root.right
        while curr and curr.left:
            curr = curr.left
        return curr

    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        self.keyNodePar = None
        self.dir = -1
        # search for the node
        keyNode = self.searchNode(root, None, -1, key)
        
        # if node not found
        if not keyNode:
            return root
    
        # case 1: if node is a leaf node, then simply remove the node
        if not keyNode.left and not keyNode.right:
            # if the keyNode is not root node
            if keyNode != root:
                if self.dir == 1:
                    self.keyNodePar.left = None
                    
                else:
                    self.keyNodePar.right = None
                return root
            
            # if the keyNode is root node
            else:
                return None
        
        # case 2: if only left child, make the left child as child of keynode's parent
        elif keyNode.left and not keyNode.right:
            # if the keyNode is not root node
            if keyNode != root:
                if self.dir == 1:
                    self.keyNodePar.left = keyNode.left
                    
                else:
                    self.keyNodePar.right = keyNode.left
                return root
            
            # if the keyNode is root node
            else:
                return root.left
        
        # case 3: if only right child, make the right child as child of keynode's parent
        elif not keyNode.left and keyNode.right:
            # if the keyNode is not root node
            if keyNode != root:
                if self.dir == 1:
                    self.keyNodePar.left = keyNode.right
                    
                else:
                    self.keyNodePar.right = keyNode.right
                return root
            
            # if the keyNode is root node
            else:
                return root.right
        
        # case 4: if both childrens exist (important)
        else:
            # search for successor of keyNode
            prince = self.findPrince(keyNode)

            # make the value of keyNode = successor node
            keyNode.val = prince.val

            # delete succesor node from right subtree of keuNode
            keyNode.right = self.deleteNode(keyNode.right, prince.val)
            return root
arctan2 vs arctan

